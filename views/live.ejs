<html>
  <head>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9"
      crossorigin="anonymous"
    />
    <link rel="short icon" href="/img/logo.png" />
  </head>

  <body>
    <h1 data-title="<%=title%>" id="title"><%=title%> 라이브중!</h1>
    <div>
      <button type="button" class="btn btn-primary" id="exit">나가기</button>
      <video id="myFace" playsinline width="1000" height="800" autoplay></video>
      <div id="peerStreams"></div>
      <button type="button" class="btn btn-primary" id="mute">음소거</button>
      <button type="button" class="btn btn-primary" id="camera">
        카메라 끄기
      </button>
      <select
        id="cameras"
        class="form-select"
        aria-label="Default select example"
      >
        <option value="device" selected disabled hidden>카메라 옵션</option>
      </select>
    </div>
    <div>
      <ul class="chatList"></ul>
      <div class="mb-3">
        <input
          type="text"
          class="form-control"
          id="chatInput"
          placeholder="채팅을 쳐주세요"
        />
        <button type="button" class="btn btn-primary chatInputBtn">채팅</button>
      </div>
    </div>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.socket.io/4.3.2/socket.io.min.js"
      integrity="sha384-KAZ4DtjNhLChOB/hxXuKqhMLYvx3b5MlT55xPEiNmREKRzeEm+RVPlTnAn0ajQNs"
      crossorigin="anonymous"
    ></script>
    <script>
      const socket = io();

      const myFaceVideo = document.getElementById('myFace');
      const muteButton = document.getElementById('mute');
      const cameraButton = document.getElementById('camera');
      const camerasSelect = document.getElementById('cameras');
      const roomExit = document.getElementById('exit');
      const roomName = document
        .querySelector('#title')
        .getAttribute('data-title');

      // const welcome = document.getElementById('welcome');
      // const call = document.getElementById('call');
      const peerStreams = document.getElementById('peerStreams');
      const chatInput = document.querySelector('#chatInput');
      const chatInputBtn = document.querySelector('.chatInputBtn');

      // call.hidden = true;

      let myStream;
      let muted = false;
      let cameraOff = false;
      let peerConnections = new Map();

      window.onload = () => {
        initCall();
      };

      //- 채팅 하기 -//
      chatInputBtn.addEventListener('click', async () => {
        if (chatInput.value.replace(/ /g, '').length === 0) return;
        await socket.emit('chatInput', {
          chat: chatInput.value,
          roomName,
        });
        chatInput.value = '';
      });

      //- 채팅 내용 보여주기 -//
      socket.on('newMsg', (msg) => {
        const li = document.createElement('li');
        li.innerText = `${msg}`;
        chatList.append(li);
      });

      async function getCameras() {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const cameras = devices.filter(
            (device) => device.kind === 'videoinput',
          );
          const currentCamera = myStream.getVideoTracks()[0];
          cameras.forEach((camera) => {
            const option = document.createElement('option');
            option.value = camera.deviceId;
            option.innerText = camera.label;
            if (currentCamera.label === camera.label) {
              option.selected = true;
            }
            camerasSelect.appendChild(option);
          });
        } catch (e) {
          console.log(e);
        }
      }

      async function getMedia(deviceId) {
        const initialConstrains = {
          audio: true,
          video: { facingMode: 'user' },
        };
        const cameraConstrains = {
          audio: true,
          video: { deviceId: { exact: deviceId } },
        };

        try {
          myStream = await navigator.mediaDevices.getUserMedia(
            deviceId ? cameraConstrains : initialConstrains,
          );
          myFaceVideo.srcObject = myStream;
          if (!deviceId) {
            await getCameras();
          }
        } catch (e) {
          console.log(e);
        }
      }

      //getMedia();

      function handleMuteClick() {
        myStream
          .getAudioTracks()
          .forEach((track) => (track.enabled = !track.enabled));
        if (!muted) {
          muteButton.innerText = 'Unmute';
          muted = true;
        } else {
          muteButton.innerText = 'Mute';
          muted = false;
        }
      }

      function handleCameraClick() {
        myStream
          .getVideoTracks()
          .forEach((track) => (track.enabled = !track.enabled));
        if (cameraOff) {
          cameraButton.innerText = 'Turn Camera Off';
          cameraOff = false;
        } else {
          cameraButton.innerText = 'Turn Camera On';
          cameraOff = true;
        }
      }

      async function handleCameraChange() {
        await getMedia(camerasSelect.value);
        for (var [key, value] of peerConnections) {
          const videoTrack = myStream.getVideoTracks()[0];
          const videoSender = value
            .getSenders()
            .find((sender) => sender.track.kind === 'video');
          videoSender.replaceTrack(videoTrack);
        }
      }

      function handleRoomExit() {
        if (myStream) {
          myStream.getTracks().forEach((track) => track.stop());
        }
        myStream = null;
        muted = false;
        cameraOff = false;
        myFaceVideo.srcObject = null;

        const videos = peerStreams.querySelectorAll('video');
        for (let i = 0; i < videos.length; i++) {
          peerStreams.removeChild(videos[i]);
        }

        for (let [key, value] in peerConnections) {
          if (value) {
            value.iceCandidate().clear();
            value.close();
          }
        }

        peerConnections.clear();

        socket.emit('roomExit', roomName);
        roomName = '';

        //   call.hidden = true;
        //   welcome.hidden = false;
      }

      function getRemoteStreamVideo(stream) {
        const videos = peerStreams.querySelectorAll('video');
        for (let i = 0; i < videos.length; i++) {
          if (stream instanceof MediaStream) {
            if (videos[i].srcObject.id === stream.id) {
              return videos[i];
            }
          } else if (stream instanceof MediaStreamTrack) {
            if (videos[i].srcObject.getVideoTracks()[0].id === stream.id) {
              return videos[i];
            }
          }
        }
      }

      muteButton.addEventListener('click', handleMuteClick);
      cameraButton.addEventListener('click', handleCameraClick);
      camerasSelect.addEventListener('input', handleCameraChange);
      roomExit.addEventListener('click', handleRoomExit);

      // Welcom Form (join a room)

      // welcomeForm = welcome.querySelector("form");

      async function initCall() {
        //   welcome.hidden = true;
        //   call.hidden = false;
        await getMedia();
        socket.emit('join_room', roomName);
      }

      // async function handleWelcomeSubmit(event) {
      //   event.preventDefault();
      //   await initCall();

      // }

      // welcomeForm.addEventListener("submit", handleWelcomeSubmit);

      // Socket Code
      //A
      socket.on('welcome', async (socketId) => {
        console.log('welcome');
        makeConnection(socketId);
        const peerConnection = peerConnections.get(socketId);
        const offer = await peerConnection.createOffer();
        peerConnection.setLocalDescription(offer);
        socket.emit('offer', { offer, socketId });
      });
      //B
      socket.on('offer', async (offer, socketId) => {
        console.log('offer');
        makeConnection(socketId);
        const peerConnection = peerConnections.get(socketId);
        peerConnection.setRemoteDescription(offer);
        const answer = await peerConnection.createAnswer();
        peerConnection.setLocalDescription(answer);
        socket.emit('answer', { answer, socketId });
      });
      //A - 확인 필요
      //have-local-offer
      //have-remote-offer
      socket.on('answer', (answer, socketId) => {
        console.log('answer - ', socketId);
        const peerConnection = peerConnections.get(socketId);
        console.log('answer signalingState - ', peerConnection.signalingState);
        if (
          !peerConnection.remoteDescription &&
          (peerConnection.signalingState === 'have-local-offer' ||
            peerConnection.signalingState === 'have-remote-offer')
        ) {
          peerConnection.setRemoteDescription(answer);
        }
      });

      socket.on('ice', (ice, socketId) => {
        if (ice) {
          const peerConnection = peerConnections.get(socketId);
          if (peerConnection) {
            peerConnection.addIceCandidate(ice);
          }
        }
      });
      //signalingState = "stable"
      socket.on('leave', (socketId) => {
        console.log('leave - ', socketId);
        const peerConnection = peerConnections.get(socketId);
        console.log('leave - ', peerConnection);
        //video view 삭제, peerConnection close, Map 에서 삭제
        //getRemoteStreams() not work! in safari
        let remoteStream;
        if (peerConnection.getRemoteStreams) {
          remoteStream = peerConnection.getRemoteStreams()[0];
        } else {
          remoteStream = peerConnection
            .getReceivers()
            .find((receiver) => receiver.track.kind === 'video').track;
        }
        const remoteStreamVideo = getRemoteStreamVideo(remoteStream);
        console.log('leave remoteStreamVideo - ', remoteStreamVideo);
        if (remoteStreamVideo) {
          peerStreams.removeChild(remoteStreamVideo);
        }
        peerConnection.close();
        peerConnections.delete(socketId);
      });

      // WEB RTC Code

      function makeConnection(socketId) {
        let peerConnection = new RTCPeerConnection({
          iceServers: [
            {
              urls: [
                'stun:stun.l.google.com:19302',
                'stun:stun1.l.google.com:19302',
                'stun:stun2.l.google.com:19302',
                'stun:stun3.l.google.com:19302',
                'stun:stun4.l.google.com:19302',
              ],
            },
          ],
        });
        peerConnection.addEventListener('icecandidate', handleIce);
        //safari 에서 사용 안됨
        //peerConnection.addEventListener("addstream", handleAddStream);
        if (peerConnection.addTrack !== undefined) {
          peerConnection.ontrack = (event) => {
            event.streams.forEach((stream) => handleAddStream(stream));
          };
        } else {
          peerConnection.onaddstream = (event) => {
            handleAddStream(event.stream);
          };
        }
        myStream
          .getTracks()
          .forEach((track) => peerConnection.addTrack(track, myStream));
        peerConnections.set(socketId, peerConnection);
      }

      function handleIce(data) {
        console.log('handleIce - ', data.candidate);
        for (let [key, value] of peerConnections) {
          if (value === data.target) {
            console.log('handleIce - ', key);
            socket.emit('ice', { ice: data.candidate, id: key });
            break;
          }
        }
      }

      //video#peerFace(autoplay, playsinline, width="400", height="400")

      function handleAddStream(stream) {
        const addedVideo = getRemoteStreamVideo(stream);
        console.log('handleAddStream isAddedVideo - ', addedVideo);
        if (!addedVideo) {
          const peerFace = document.createElement('video');
          peerFace.autoplay = true;
          peerFace.playsinline = true;
          peerFace.width = 400;
          peerFace.height = 400;
          peerFace.srcObject = stream;

          peerStreams.appendChild(peerFace);
        }
      }
    </script>
  </body>
</html>
